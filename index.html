<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Fog of War - Real World Map</title>

    <!-- Leaflet CSS -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
          integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY="
          crossorigin=""/>

    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body, html {
            width: 100%;
            height: 100%;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            overflow: hidden;
        }

        #map {
            width: 100%;
            height: 100%;
            position: absolute;
            top: 0;
            left: 0;
        }

        #fog-canvas {
            position: absolute;
            top: 0;
            left: 0;
            pointer-events: none;
            z-index: 1000;
        }

        .leaflet-top,
        .leaflet-bottom,
        .leaflet-control {
            z-index: 1001 !important;
        }

        #controls-top-right {
            position: absolute;
            top: 10px;
            right: 10px;
            z-index: 1001;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        #controls-bottom-left {
            position: absolute;
            bottom: 10px;
            left: 10px;
            z-index: 1001;
        }

        #controls-bottom-right {
            position: absolute;
            bottom: 10px;
            right: 10px;
            z-index: 1001;
        }

        button {
            width: 44px;
            height: 44px;
            padding: 0;
            border: none;
            border-radius: 50%;
            font-size: 24px;
            cursor: pointer;
            transition: all 0.2s;
            box-shadow: 0 2px 8px rgba(0,0,0,0.2);
            background: white;
            color: #333;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        button:hover {
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
            transform: scale(1.05);
        }

        button:active {
            transform: scale(0.95);
        }

        button {
            background: white;
            color: #000;
        }

        #radius-control {
            background: white;
            padding: 10px 12px;
            border-radius: 22px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.2);
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 12px;
            font-weight: 600;
            color: #333;
        }

        #radius-slider {
            width: 80px;
            cursor: pointer;
        }

        #radius-value {
            min-width: 35px;
            text-align: right;
        }

        .error {
            position: absolute;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 1001;
            color: #dc3545;
            font-size: 12px;
            background: white;
            padding: 8px 12px;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.2);
            max-width: 200px;
            display: none;
        }

        .error:not(:empty) {
            display: block;
        }

        .satellite-layer {
            filter: brightness(0.6) contrast(1.1);
        }
    </style>
</head>
<body>
    <div id="map"></div>
    <canvas id="fog-canvas"></canvas>

    <div id="controls-top-right">
        <button id="center-btn" title="Center on My Location">⊙</button>
        <button id="reset-btn" title="Reset All Data">↻</button>
    </div>

    <div id="controls-bottom-left">
        <button id="basemap-btn" title="Toggle Satellite/Street">◐</button>
    </div>

    <div id="controls-bottom-right">
        <div id="radius-control">
            <input type="range" id="radius-slider" min="15" max="100" value="20" step="5">
            <span id="radius-value">20m</span>
        </div>
    </div>

    <div id="error-msg" class="error"></div>

    <!-- Leaflet JS -->
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
            integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo="
            crossorigin=""></script>

    <script>
        // Configuration
        const CONFIG = {
            FOG_COLOR: 'rgba(255, 255, 255, 0.9)',
            FOG_REVEAL_RADIUS: 20, // meters
            GPS_MIN_MOVEMENT: 20, // meters
            GPS_UPDATE_INTERVAL: 10000, // ms
            GPS_MAX_ACCURACY: 100, // meters
            MAX_STORED_POINTS: 10000,
            STORAGE_KEY: 'fogOfWarData',
            DEFAULT_CENTER: [40.7128, -74.0060], // NYC
            DEFAULT_ZOOM: 13
        };

        // State
        const state = {
            map: null,
            canvas: null,
            ctx: null,
            visitedLocations: [],
            currentPosition: null,
            currentMarker: null,
            watchId: null,
            lastSaveTime: 0,
            noiseCanvas: null,
            noiseCtx: null,
            streetLayer: null,
            satelliteLayer: null,
            currentLayer: 'satellite',
            hasInitialCentered: false,
            currentAccuracy: null,
            animationFrame: null,
            animationStartTime: Date.now(),
            lastAnimationFrame: 0
        };

        // Initialize the application
        function init() {
            initMap();
            initFogCanvas();
            loadFromLocalStorage();
            initGeolocation();
            setupEventListeners();
            animateFog(); // Start animation loop
        }

        // Initialize Leaflet map
        function initMap() {
            state.map = L.map('map', {
                attributionControl: false
            }).setView(CONFIG.DEFAULT_CENTER, CONFIG.DEFAULT_ZOOM);

            // Create dark layer (Carto Dark Matter)
            state.streetLayer = L.tileLayer('https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}{r}.png', {
                attribution: '© OpenStreetMap contributors © CARTO',
                maxZoom: 19
            });

            // Create satellite layer (Esri World Imagery)
            state.satelliteLayer = L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', {
                attribution: '© Esri',
                maxZoom: 19,
                className: 'satellite-layer'
            });

            // Start with satellite layer
            state.satelliteLayer.addTo(state.map);
        }

        // Initialize fog canvas
        function initFogCanvas() {
            state.canvas = document.getElementById('fog-canvas');
            state.ctx = state.canvas.getContext('2d');
            resizeFogCanvas();

            // Handle window resize
            window.addEventListener('resize', () => {
                resizeFogCanvas();
                drawFog();
            });
        }

        // Resize canvas to match map container
        function resizeFogCanvas() {
            const mapContainer = document.getElementById('map');
            state.canvas.width = mapContainer.offsetWidth;
            state.canvas.height = mapContainer.offsetHeight;
        }

        // Convert lat/lng to canvas pixel coordinates
        function latLngToCanvasCoords(lat, lng) {
            const point = state.map.latLngToContainerPoint([lat, lng]);
            return { x: point.x, y: point.y };
        }

        // Calculate distance between two points in meters
        function calculateDistance(lat1, lng1, lat2, lng2) {
            const R = 6371000; // Earth's radius in meters
            const φ1 = lat1 * Math.PI / 180;
            const φ2 = lat2 * Math.PI / 180;
            const Δφ = (lat2 - lat1) * Math.PI / 180;
            const Δλ = (lng2 - lng1) * Math.PI / 180;

            const a = Math.sin(Δφ / 2) * Math.sin(Δφ / 2) +
                      Math.cos(φ1) * Math.cos(φ2) *
                      Math.sin(Δλ / 2) * Math.sin(Δλ / 2);
            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));

            return R * c;
        }

        // Convert meters to pixels at current zoom level
        function metersToPixels(meters, lat) {
            const metersPerPixel = 156543.03392 * Math.cos(lat * Math.PI / 180) / Math.pow(2, state.map.getZoom());
            return meters / metersPerPixel;
        }

        // Simple hash function for pseudo-random noise
        function hash(x, y) {
            const h = Math.sin(x * 12.9898 + y * 78.233) * 43758.5453;
            return h - Math.floor(h);
        }

        // Smoothstep interpolation
        function smoothstep(t) {
            return t * t * (3 - 2 * t);
        }

        // 2D Perlin-like noise
        function noise(x, y) {
            const xi = Math.floor(x);
            const yi = Math.floor(y);
            const xf = x - xi;
            const yf = y - yi;

            const n00 = hash(xi, yi);
            const n10 = hash(xi + 1, yi);
            const n01 = hash(xi, yi + 1);
            const n11 = hash(xi + 1, yi + 1);

            const u = smoothstep(xf);
            const v = smoothstep(yf);

            const nx0 = n00 * (1 - u) + n10 * u;
            const nx1 = n01 * (1 - u) + n11 * u;

            return nx0 * (1 - v) + nx1 * v;
        }

        // Multi-octave noise (Fractal Brownian Motion)
        function fbm(x, y, octaves = 4) {
            let value = 0;
            let amplitude = 1;
            let frequency = 1;
            let maxValue = 0;

            for (let i = 0; i < octaves; i++) {
                value += noise(x * frequency, y * frequency) * amplitude;
                maxValue += amplitude;
                amplitude *= 0.5;
                frequency *= 2;
            }

            return value / maxValue;
        }

        // Generate cloudy fog texture with time offset for animation
        function generateCloudTexture(width, height, timeOffset = 0) {
            const canvas = document.createElement('canvas');
            canvas.width = width;
            canvas.height = height;
            const ctx = canvas.getContext('2d');

            const imageData = ctx.createImageData(width, height);
            const data = imageData.data;

            const scale = 0.005; // Adjust for cloud size

            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    const i = (y * width + x) * 4;

                    // Multi-octave noise for realistic clouds with time offset
                    const noiseValue = fbm(
                        x * scale + timeOffset * 2,
                        y * scale + timeOffset * 1,
                        5
                    );

                    // Map noise to white/gray fog colors
                    const brightness = 200 + noiseValue * 55; // 200-255 range
                    const alpha = 0.85 + noiseValue * 0.15; // Varying opacity

                    data[i] = brightness;     // R
                    data[i + 1] = brightness; // G
                    data[i + 2] = brightness; // B
                    data[i + 3] = alpha * 255; // A
                }
            }

            ctx.putImageData(imageData, 0, 0);
            return canvas;
        }

        // Draw fog with reveals
        function drawFog() {
            if (!state.ctx || !state.canvas) return;

            const ctx = state.ctx;
            const canvas = state.canvas;

            // Clear canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Calculate time offset for animation (very subtle drift)
            const timeOffset = (Date.now() - state.animationStartTime) / 12000;

            // Generate at half resolution for performance, then scale up
            const texWidth = Math.floor(canvas.width / 2);
            const texHeight = Math.floor(canvas.height / 2);
            state.noiseCanvas = generateCloudTexture(texWidth, texHeight, timeOffset);

            // Draw scaled up (4x faster generation, minimal visual difference)
            ctx.imageSmoothingEnabled = true;
            ctx.drawImage(state.noiseCanvas, 0, 0, canvas.width, canvas.height);

            // Set composite mode to "erase" fog
            ctx.globalCompositeOperation = 'destination-out';

            // Get map bounds for viewport culling
            const bounds = state.map.getBounds();

            // Draw reveals for each visited location
            state.visitedLocations.forEach(location => {
                // Viewport culling - skip if outside visible area
                if (!bounds.contains([location.lat, location.lng])) {
                    return;
                }

                const coords = latLngToCanvasCoords(location.lat, location.lng);
                const radiusPixels = metersToPixels(location.radius, location.lat);

                // Draw multiple concentric wavy rings with decreasing opacity for fadeout
                const numRings = 100;
                const noiseScale = 0.3;
                const segments = 1000;

                for (let ring = 0; ring < numRings; ring++) {
                    const ringProgress = ring / numRings; // 0 to ~0.875
                    const ringRadius = radiusPixels * (0.5 + ringProgress * 1.0); // 0.5x to 1.5x base radius
                    const ringAlpha = 1.0 - (ringProgress * ringProgress); // Quadratic falloff for smoother fade

                    ctx.fillStyle = `rgba(0, 0, 0, ${ringAlpha})`;

                    // Draw wavy shape for this ring
                    ctx.beginPath();

                    for (let i = 0; i <= segments; i++) {
                        const angle = (i / segments) * Math.PI * 2;

                        const noiseValue = fbm(
                            location.lat * 1000 + Math.cos(angle) * 5 + timeOffset * 3,
                            location.lng * 1000 + Math.sin(angle) * 5 + timeOffset * 2,
                            2
                        );
                        const radiusVariation = 1 + (noiseValue - 0.5) * noiseScale;
                        const variedRadius = ringRadius * radiusVariation;

                        const x = coords.x + Math.cos(angle) * variedRadius;
                        const y = coords.y + Math.sin(angle) * variedRadius;

                        if (i === 0) {
                            ctx.moveTo(x, y);
                        } else {
                            ctx.lineTo(x, y);
                        }
                    }
                    ctx.closePath();
                    ctx.fill();
                }
            });

            // Reset composite mode
            ctx.globalCompositeOperation = 'source-over';
        }

        // Animation loop for cloud drift (60fps for smooth animation)
        function animateFog(timestamp) {
            drawFog();
            state.animationFrame = requestAnimationFrame(animateFog);
        }

        // Initialize Geolocation
        function initGeolocation() {
            if (!navigator.geolocation) {
                showError('Geolocation is not supported by your browser');
                return;
            }

            const options = {
                enableHighAccuracy: true,
                maximumAge: 5000,
                timeout: 10000
            };

            state.watchId = navigator.geolocation.watchPosition(
                onPositionUpdate,
                onPositionError,
                options
            );
        }

        // Handle position update
        function onPositionUpdate(position) {
            const { latitude, longitude, accuracy } = position.coords;

            // Filter out low-accuracy readings
            if (accuracy > CONFIG.GPS_MAX_ACCURACY) {
                return;
            }

            // Store current accuracy
            state.currentAccuracy = accuracy;

            // Center map on user's location on first GPS fix
            if (!state.hasInitialCentered) {
                state.map.setView([latitude, longitude], 18);
                state.hasInitialCentered = true;
            }

            // Update current position marker
            updateCurrentMarker(latitude, longitude);

            // Check if we should add a new visited location
            const shouldAddLocation = state.visitedLocations.length === 0 ||
                calculateDistance(
                    latitude, longitude,
                    state.visitedLocations[state.visitedLocations.length - 1].lat,
                    state.visitedLocations[state.visitedLocations.length - 1].lng
                ) > CONFIG.GPS_MIN_MOVEMENT;

            if (shouldAddLocation) {
                addVisitedLocation(latitude, longitude, accuracy);
            }

            state.currentPosition = { lat: latitude, lng: longitude };
        }

        // Handle position error
        function onPositionError(error) {
            let message = '';
            switch(error.code) {
                case error.PERMISSION_DENIED:
                    message = 'Location permission denied';
                    break;
                case error.POSITION_UNAVAILABLE:
                    message = 'Location unavailable';
                    break;
                case error.TIMEOUT:
                    message = 'Location request timeout';
                    break;
                default:
                    message = 'Unknown location error';
            }
            showError(message);
        }

        // Add a new visited location
        function addVisitedLocation(lat, lng, accuracy) {
            const location = {
                lat: lat,
                lng: lng,
                radius: CONFIG.FOG_REVEAL_RADIUS,
                timestamp: Date.now()
            };

            state.visitedLocations.push(location);

            // Cap at max points
            if (state.visitedLocations.length > CONFIG.MAX_STORED_POINTS) {
                state.visitedLocations.shift();
            }

            drawFog();
            saveToLocalStorage();
        }

        // Update current position marker
        function updateCurrentMarker(lat, lng) {
            if (state.currentMarker) {
                state.currentMarker.setLatLng([lat, lng]);
            } else {
                state.currentMarker = L.circleMarker([lat, lng], {
                    radius: 8,
                    color: '#007bff',
                    fillColor: '#007bff',
                    fillOpacity: 0.8,
                    weight: 2
                }).addTo(state.map);
            }
        }

        // Save to localStorage
        function saveToLocalStorage() {
            // Debounce saves
            const now = Date.now();
            if (now - state.lastSaveTime < 5000) return;
            state.lastSaveTime = now;

            try {
                const data = {
                    version: 1,
                    visitedLocations: state.visitedLocations,
                    revealRadius: CONFIG.FOG_REVEAL_RADIUS,
                    timestamp: now
                };
                localStorage.setItem(CONFIG.STORAGE_KEY, JSON.stringify(data));
            } catch (error) {
                console.error('Failed to save to localStorage:', error);
                showError('Failed to save data');
            }
        }

        // Load from localStorage
        function loadFromLocalStorage() {
            try {
                const dataStr = localStorage.getItem(CONFIG.STORAGE_KEY);
                if (dataStr) {
                    const data = JSON.parse(dataStr);
                    state.visitedLocations = data.visitedLocations || [];

                    // Restore slider value if saved
                    if (data.revealRadius) {
                        CONFIG.FOG_REVEAL_RADIUS = data.revealRadius;
                        const slider = document.getElementById('radius-slider');
                        const valueDisplay = document.getElementById('radius-value');
                        if (slider && valueDisplay) {
                            slider.value = data.revealRadius;
                            valueDisplay.textContent = `${data.revealRadius}m`;
                        }

                        // Update all loaded locations to use saved radius
                        state.visitedLocations.forEach(location => {
                            location.radius = data.revealRadius;
                        });
                    }

                    drawFog();
                }
            } catch (error) {
                console.error('Failed to load from localStorage:', error);
                showError('Failed to load saved data');
            }
        }

        // Clear all data
        function clearAllData() {
            if (!confirm('Are you sure you want to reset all data? This cannot be undone.')) {
                return;
            }

            state.visitedLocations = [];
            localStorage.removeItem(CONFIG.STORAGE_KEY);
            drawFog();
        }

        // Center map on current location
        function centerOnCurrentLocation() {
            if (state.currentPosition) {
                state.map.panTo([state.currentPosition.lat, state.currentPosition.lng]);
            } else if (state.visitedLocations.length > 0) {
                const lastLocation = state.visitedLocations[state.visitedLocations.length - 1];
                state.map.panTo([lastLocation.lat, lastLocation.lng]);
            } else {
                showError('No location available yet');
            }
        }

        // Toggle basemap between street and satellite
        function toggleBasemap() {
            if (state.currentLayer === 'street') {
                state.map.removeLayer(state.streetLayer);
                state.satelliteLayer.addTo(state.map);
                state.currentLayer = 'satellite';
            } else {
                state.map.removeLayer(state.satelliteLayer);
                state.streetLayer.addTo(state.map);
                state.currentLayer = 'street';
            }
        }

        // Setup event listeners
        function setupEventListeners() {
            document.getElementById('center-btn').addEventListener('click', centerOnCurrentLocation);
            document.getElementById('basemap-btn').addEventListener('click', toggleBasemap);
            document.getElementById('reset-btn').addEventListener('click', clearAllData);

            const radiusSlider = document.getElementById('radius-slider');
            const radiusValue = document.getElementById('radius-value');

            radiusSlider.addEventListener('input', (e) => {
                const newRadius = parseInt(e.target.value);
                CONFIG.FOG_REVEAL_RADIUS = newRadius;
                radiusValue.textContent = `${newRadius}m`;

                // Update all existing locations with new radius
                state.visitedLocations.forEach(location => {
                    location.radius = newRadius;
                });

                drawFog();
            });
        }

        // Show error message
        function showError(message) {
            const errorEl = document.getElementById('error-msg');
            errorEl.textContent = message;
            setTimeout(() => {
                errorEl.textContent = '';
            }, 5000);
        }

        // Start the application
        window.addEventListener('DOMContentLoaded', init);
    </script>
</body>
</html>
